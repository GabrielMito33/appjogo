#!/usr/bin/env python3
"""
ü§ñ BOT AVAN√áADO COM VARI√ÅVEIS GLOBAIS
Vers√£o do sistema de bots que usa todas as vari√°veis personalizadas
Integra com o sistema de processamento de vari√°veis avan√ßadas
"""

import json
import threading
import time
import requests
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional
from sistema_variaveis_mensagens import ProcessadorVariaveisGlobais

class BotAvancadoComVariaveis:
    def __init__(self, config: Dict):
        self.config = config
        self.id = config["id"]
        self.name = config["name"]
        self.token = config["token"]
        self.chat_id = config["chat_id"]
        self.active = config["active"]
        self.estrategias_file = config["estrategias_file"]
        self.mensagens = config["mensagens"]
        self.bot_config = config["config"]
        
        # Sistema de vari√°veis globais
        self.processador_variaveis = ProcessadorVariaveisGlobais()
        self.processador_variaveis.stats['max_gales'] = self.bot_config.get('max_gales', 2)
        
        # Estado do bot
        self.running = False
        self.thread = None
        self.estrategias = []
        self.ultimo_resultado = None
        self.historico_resultados = []
        self.gales_ativos = {}
        
        # Controle de data para reset di√°rio
        self.data_atual = datetime.now().date()
        
        # API Telegram
        self.telegram_api = f"https://api.telegram.org/bot{self.token}"
    
    def verificar_mudanca_dia(self):
        """Verifica se mudou o dia e reseta estat√≠sticas se necess√°rio"""
        hoje = datetime.now().date()
        if hoje != self.data_atual:
            self.log("üåÖ Novo dia detectado - resetando estat√≠sticas di√°rias")
            self.processador_variaveis.resetar_estatisticas_diarias()
            self.data_atual = hoje
    
    def log(self, message: str, level: str = "INFO"):
        """Log espec√≠fico do bot"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] [{self.name}] {level}: {message}")
    
    def carregar_estrategias(self) -> bool:
        """Carrega estrat√©gias espec√≠ficas do bot"""
        estrategias_path = Path(self.estrategias_file)
        
        if not estrategias_path.exists():
            self.log(f"‚ùå Arquivo de estrat√©gias n√£o encontrado: {estrategias_path}", "ERROR")
            return False
        
        self.estrategias = []
        
        try:
            with open(estrategias_path, 'r', encoding='utf-8') as f:
                for i, line in enumerate(f):
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    
                    if "=" not in line:
                        continue
                    
                    condicoes_str, aposta_str = line.split("=", 1)
                    condicoes = [c.strip() for c in condicoes_str.split("-")]
                    aposta = aposta_str.strip()
                    
                    if aposta in ["V", "P", "B"]:
                        self.estrategias.append({
                            "id": i + 1,
                            "conditions": condicoes,
                            "bet_direction": aposta,
                            "original": line,
                            "active": True,
                            "name": f"Estrat√©gia {i+1}"
                        })
            
            self.log(f"‚úÖ Carregadas {len(self.estrategias)} estrat√©gias")
            return len(self.estrategias) > 0
            
        except Exception as e:
            self.log(f"‚ùå Erro ao carregar estrat√©gias: {e}", "ERROR")
            return False
    
    def convert_number_to_color(self, number: int) -> str:
        """Converte n√∫mero para cor"""
        if 1 <= number <= 7:
            return "V"
        elif 8 <= number <= 14:
            return "P"
        else:
            return "B"
    
    def get_color_emoji(self, color: str) -> str:
        """Converte cor para emoji"""
        mapping = {"V": "üî¥", "P": "‚ö´", "B": "‚ö™"}
        return mapping.get(color, "‚ùì")
    
    def get_color_name(self, color: str) -> str:
        """Converte cor para nome"""
        mapping = {"V": "VERMELHO", "P": "PRETO", "B": "BRANCO"}
        return mapping.get(color, "DESCONHECIDO")
    
    def fetch_blaze_results(self) -> List[int]:
        """Busca resultados da Blaze"""
        try:
            response = requests.get(
                "https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/1",
                timeout=10
            )
            if response.status_code == 200:
                data = response.json()
                return [item['roll'] for item in data]
            return []
        except Exception as e:
            self.log(f"Erro ao buscar Blaze: {e}", "ERROR")
            return []
    
    def send_telegram_message(self, message: str) -> bool:
        """Envia mensagem personalizada do bot"""
        try:
            response = requests.post(
                f"{self.telegram_api}/sendMessage",
                json={
                    "chat_id": self.chat_id,
                    "text": message,
                    "parse_mode": "Markdown"
                },
                timeout=10
            )
            return response.status_code == 200
        except Exception as e:
            self.log(f"Erro ao enviar Telegram: {e}", "ERROR")
            return False
    
    def verificar_estrategia(self, estrategia: Dict, results: List[int]) -> bool:
        """Verifica se estrat√©gia faz match"""
        conditions = estrategia["conditions"]
        
        if len(conditions) > len(results):
            return False
        
        colors = [self.convert_number_to_color(num) for num in results]
        
        for i, condition in enumerate(conditions):
            posicao_historico = len(conditions) - 1 - i
            numero_nesta_posicao = str(results[posicao_historico])
            cor_nesta_posicao = colors[posicao_historico]
            
            if condition == "X":
                continue
            elif condition == numero_nesta_posicao or condition == cor_nesta_posicao:
                continue
            else:
                return False
        
        return True
    
    def processar_template_avancado(self, template_key: str, **kwargs) -> str:
        """Processa template usando vari√°veis globais avan√ßadas"""
        template = self.mensagens.get(template_key, "")
        if not template:
            return f"Template '{template_key}' n√£o encontrado para {self.name}"
        
        # Par√¢metros adicionais espec√≠ficos do bot
        params_bot = {
            'bot_name': self.name,
            'total_estrategias': len(self.estrategias),
            **kwargs
        }
        
        return self.processador_variaveis.processar_todas_variaveis(template, **params_bot)
    
    def send_signal(self, estrategia: Dict, results: List[int]):
        """Envia sinal com mensagem avan√ßada processada"""
        bet_direction = estrategia["bet_direction"]
        cor_emoji = self.get_color_emoji(bet_direction)
        cor_nome = self.get_color_name(bet_direction)
        
        # Atualizar nome da estrat√©gia atual no processador
        self.processador_variaveis.stats['nome_estrategia'] = estrategia['original']
        
        # Formatar dados para o template
        numeros = ', '.join(map(str, results[:5]))
        cores_emoji = ' '.join([self.get_color_emoji(self.convert_number_to_color(r)) for r in results[:5]])
        
        # Processar template de sinal
        message = self.processar_template_avancado(
            'sinal_template',
            cor_emoji=cor_emoji,
            cor_nome=cor_nome,
            estrategia=estrategia['original'],
            numeros=numeros,
            cores_emoji=cores_emoji,
            confianca=85  # Pode ser calculado dinamicamente
        )
        
        if self.send_telegram_message(message):
            # Registrar sinal enviado (por enquanto como pendente)
            self.log(f"‚úÖ SINAL ENVIADO: {estrategia['original']} -> {cor_nome}")
            
            # Armazenar para tracking de gales
            self.gales_ativos[estrategia['original']] = {
                'estrategia': estrategia,
                'cor_apostada': bet_direction,
                'gale_atual': 0,
                'timestamp': datetime.now()
            }
        else:
            self.log(f"‚ùå Falha ao enviar sinal: {estrategia['original']}")
    
    def send_alert(self, estrategia: Dict):
        """Envia alerta com mensagem avan√ßada processada"""
        # Atualizar nome da estrat√©gia no processador
        self.processador_variaveis.stats['nome_estrategia'] = estrategia['original']
        
        message = self.processar_template_avancado(
            'alerta_template',
            estrategia=estrategia['original']
        )
        
        if self.send_telegram_message(message):
            self.log(f"‚ö†Ô∏è ALERTA ENVIADO: {estrategia['original']}")
    
    def processar_resultado_gales(self, novo_resultado: int):
        """Processa resultado para verificar gales ativos"""
        cor_resultado = self.convert_number_to_color(novo_resultado)
        
        gales_finalizados = []
        
        for estrategia_original, info_gale in self.gales_ativos.items():
            cor_apostada = info_gale['cor_apostada']
            gale_atual = info_gale['gale_atual']
            estrategia = info_gale['estrategia']
            
            # Verificar se foi WIN
            if cor_resultado == cor_apostada or cor_resultado == "B":  # B = prote√ß√£o
                resultado_tipo = "WIN" if cor_resultado == cor_apostada else "BRANCO"
                
                # Atualizar estat√≠sticas
                self.processador_variaveis.atualizar_estatisticas(
                    resultado_tipo, 
                    gale_atual, 
                    estrategia['original']
                )
                
                # Enviar mensagem de resultado WIN
                self.send_win_message(estrategia, gale_atual, resultado_tipo)
                
                gales_finalizados.append(estrategia_original)
                
            else:
                # Foi RED, verificar se deve fazer gale
                max_gales = self.bot_config.get('max_gales', 2)
                
                if gale_atual < max_gales:
                    # Fazer pr√≥ximo gale
                    info_gale['gale_atual'] += 1
                    self.processador_variaveis.stats['gale_atual'] = info_gale['gale_atual']
                    
                    self.log(f"üé≤ Fazendo G{info_gale['gale_atual']} para {estrategia_original}")
                    
                    # Enviar mensagem de gale
                    self.send_gale_message(estrategia, info_gale['gale_atual'])
                    
                else:
                    # Esgotaram-se os gales - LOSS
                    self.processador_variaveis.atualizar_estatisticas(
                        "LOSS", 
                        gale_atual, 
                        estrategia['original']
                    )
                    
                    # Enviar mensagem de LOSS
                    self.send_loss_message(estrategia, gale_atual)
                    
                    gales_finalizados.append(estrategia_original)
        
        # Remover gales finalizados
        for estrategia_original in gales_finalizados:
            del self.gales_ativos[estrategia_original]
    
    def send_win_message(self, estrategia: Dict, gale_usado: int, tipo_resultado: str):
        """Envia mensagem de WIN com vari√°veis avan√ßadas"""
        # Verificar se existe template espec√≠fico para WIN
        template_key = 'win_template' if 'win_template' in self.mensagens else 'stats_template'
        
        if template_key not in self.mensagens:
            # Template padr√£o se n√£o existir
            message = f"‚úÖ **GREEN** - {estrategia['original']} {'de primeira' if gale_usado == 0 else f'com G{gale_usado}'}!"
        else:
            message = self.processar_template_avancado(template_key)
        
        self.send_telegram_message(message)
    
    def send_loss_message(self, estrategia: Dict, gales_usados: int):
        """Envia mensagem de LOSS com vari√°veis avan√ßadas"""
        template_key = 'loss_template' if 'loss_template' in self.mensagens else 'stats_template'
        
        if template_key not in self.mensagens:
            message = f"‚ùå **RED** - {estrategia['original']} ap√≥s {gales_usados} gales"
        else:
            message = self.processar_template_avancado(template_key)
        
        self.send_telegram_message(message)
    
    def send_gale_message(self, estrategia: Dict, gale_numero: int):
        """Envia mensagem de GALE"""
        cor_emoji = self.get_color_emoji(estrategia['bet_direction'])
        cor_nome = self.get_color_name(estrategia['bet_direction'])
        
        message = f"üé≤ **GALE {gale_numero}** - {cor_emoji} {cor_nome}"
        self.send_telegram_message(message)
    
    def send_stats(self):
        """Envia estat√≠sticas com vari√°veis avan√ßadas"""
        message = self.processar_template_avancado('stats_template')
        self.send_telegram_message(message)
    
    def processar_estrategias(self, results: List[int]):
        """Processa estrat√©gias espec√≠ficas do bot"""
        if len(results) < 2:
            return
        
        for estrategia in self.estrategias:
            if not estrategia.get("active", True):
                continue
            
            # Pular se j√° tem gale ativo desta estrat√©gia
            if estrategia['original'] in self.gales_ativos:
                continue
            
            # Verificar sinal completo
            if self.verificar_estrategia(estrategia, results):
                self.log(f"üéØ MATCH: {estrategia['original']}")
                self.send_signal(estrategia, results)
                return  # Parar ap√≥s primeiro match
    
    def run_bot(self):
        """Loop principal do bot com vari√°veis avan√ßadas"""
        self.log("üöÄ Bot iniciado com sistema de vari√°veis avan√ßadas")
        
        # Mensagem de in√≠cio
        message = self.processar_template_avancado('inicio_template')
        self.send_telegram_message(message)
        
        while self.running:
            try:
                # Verificar mudan√ßa de dia
                self.verificar_mudanca_dia()
                
                # Buscar resultados
                results = self.fetch_blaze_results()
                
                if results and results[0] != self.ultimo_resultado:
                    novo_resultado = results[0]
                    
                    # Processar gales ativos primeiro
                    if self.gales_ativos:
                        self.processar_resultado_gales(novo_resultado)
                    
                    # Atualizar estado
                    self.ultimo_resultado = novo_resultado
                    self.historico_resultados = results
                    
                    cor = self.convert_number_to_color(novo_resultado)
                    emoji = self.get_color_emoji(cor)
                    self.log(f"Novo resultado: {novo_resultado} ({emoji})")
                    
                    # Processar estrat√©gias para novos sinais
                    if not self.gales_ativos:  # S√≥ enviar novo sinal se n√£o tem gales ativos
                        self.processar_estrategias(results)
                
                time.sleep(self.bot_config["interval_seconds"])
                
            except Exception as e:
                self.log(f"Erro no loop: {e}", "ERROR")
                time.sleep(10)
        
        # Mensagem de finaliza√ß√£o
        message = self.processar_template_avancado('fim_template')
        self.send_telegram_message(message)
        
        self.log("üõë Bot finalizado")
    
    def start(self) -> bool:
        """Inicia o bot"""
        if self.running:
            self.log("Bot j√° est√° rodando", "WARNING")
            return False
        
        if not self.carregar_estrategias():
            return False
        
        self.running = True
        self.thread = threading.Thread(target=self.run_bot, daemon=True)
        self.thread.start()
        
        return True
    
    def stop(self):
        """Para o bot"""
        self.running = False
        if self.thread and self.thread.is_alive():
            self.thread.join(timeout=5)
    
    def obter_estatisticas_avancadas(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas avan√ßadas do bot"""
        return self.processador_variaveis.obter_resumo_estatisticas()

def main():
    """Teste do bot avan√ßado"""
    print("ü§ñ TESTE DO BOT AVAN√áADO COM VARI√ÅVEIS GLOBAIS")
    print("=" * 55)
    
    # Configura√ß√£o de teste
    config_teste = {
        "id": "bot_teste",
        "name": "Bot Teste Avan√ßado",
        "token": "8106969377:AAHp4PRKZN-RHb1GxR3C3l7PzikFHEcRsck",
        "chat_id": "-1002852101467",
        "active": True,
        "estrategias_file": "bot1_estrategias.csv",
        "config": {
            "max_gales": 2,
            "protection": True,
            "interval_seconds": 5,
            "enable_alerts": True
        },
        "mensagens": {
            "sinal_template": """üéØ [N]SINAL DETECTADO[/N] üî•

üìã **Estrat√©gia**: [NOME_ESTRATEGIA]
üé∞ **Apostar**: {cor_emoji} **{cor_nome}**
üõ°Ô∏è **Prote√ß√£o**: ‚ö™ BRANCO
üîÑ **Gales**: At√© [MAX_GALES]x

üìä **Hoje**: [WINS]W | [LOSSES]L | [PERCENTUAL_ASSERTIVIDADE]%
üî• **Sequ√™ncia**: [GANHOS_CONSECUTIVOS] seguidos

üìÖ [DATA_HOJE] | ‚è∞ [HORA_AGORA]""",
            
            "stats_template": """üìä [N]ESTAT√çSTICAS[/N] - [DATA_HOJE]

üéØ **Performance**:
‚Ä¢ ‚úÖ Wins: [WINS] | ‚ùå Losses: [LOSSES]
‚Ä¢ üìà Assertividade: [PERCENTUAL_ASSERTIVIDADE]%
‚Ä¢ üî• Sequ√™ncia: [GANHOS_CONSECUTIVOS]

üé≤ **Detalhamento**:
‚Ä¢ üéØ Sem Gale: [SG]
‚Ä¢ üé≤ G1: [G1] | G2: [G2]

‚è∞ [HORA_AGORA]""",
            
            "inicio_template": """üöÄ [N]{bot_name} ONLINE[/N]

üìã {total_estrategias} estrat√©gias carregadas
üéØ Gales: at√© [MAX_GALES]x
üìÖ [DATA_HOJE] | ‚è∞ [HORA_AGORA]

üí™ [N]VAMOS LUCRAR![/N]""",
            
            "fim_template": """üõë [N]{bot_name} OFFLINE[/N]

üìä **Resumo**: [WINS]W | [LOSSES]L
üìà **Assertividade**: [PERCENTUAL_ASSERTIVIDADE]%

‚è∞ Finalizado √†s [HORA_AGORA]"""
        }
    }
    
    # Criar e testar bot
    bot = BotAvancadoComVariaveis(config_teste)
    
    # Simular algumas estat√≠sticas
    bot.processador_variaveis.atualizar_estatisticas('WIN', 0, 'V-V=P')
    bot.processador_variaveis.atualizar_estatisticas('WIN', 1, 'P-P=V')
    bot.processador_variaveis.atualizar_estatisticas('LOSS', 2, 'V-V-P=V')
    
    # Testar processamento de templates
    print("\nüîç TESTE DE TEMPLATES:")
    print("-" * 30)
    
    # Template de in√≠cio
    msg_inicio = bot.processar_template_avancado('inicio_template')
    print("üì® Mensagem de in√≠cio:")
    print(msg_inicio)
    print()
    
    # Template de estat√≠sticas
    msg_stats = bot.processar_template_avancado('stats_template')
    print("üì® Mensagem de estat√≠sticas:")
    print(msg_stats)
    print()
    
    # Estat√≠sticas avan√ßadas
    stats = bot.obter_estatisticas_avancadas()
    print("üìä Estat√≠sticas avan√ßadas:")
    for key, value in stats.items():
        print(f"  ‚Ä¢ {key}: {value}")

if __name__ == "__main__":
    main() 